<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SSE vs WebSocket Performance Comparison</title>
  <style>
    body { font-family: monospace; margin: 20px; background: #f5f5f5; }
    .container { max-width: 1000px; margin: 0 auto; }
    .metrics { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
    .card { background: white; padding: 15px; border: 1px solid #ddd; }
    .card h3 { margin: 0 0 10px 0; color: #333; }
    .metric { display: flex; justify-content: space-between; margin: 5px 0; }
    .status { padding: 2px 6px; border-radius: 3px; font-size: 12px; }
    .connected { background: #d4edda; color: #155724; }
    .disconnected { background: #f8d7da; color: #721c24; }
    .server-stats { background: white; padding: 15px; border: 1px solid #ddd; margin: 20px 0; }
    .comparison { background: white; padding: 15px; border: 1px solid #ddd; margin: 20px 0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>SSE vs WebSocket Performance Comparison</h1>
    
    <div class="metrics">
      <div class="card">
        <h3>Server-Sent Events</h3>
        <div class="metric">
          <span>Status:</span>
          <span id="sse-status" class="status disconnected">Disconnected</span>
        </div>
        <div class="metric">
          <span>Messages:</span>
          <span id="sse-messages">0</span>
        </div>
        <div class="metric">
          <span>Avg Latency:</span>
          <span id="sse-latency">0ms</span>
        </div>
        <div class="metric">
          <span>Last Seq:</span>
          <span id="sse-seq">-</span>
        </div>
      </div>
      
      <div class="card">
        <h3>WebSocket</h3>
        <div class="metric">
          <span>Status:</span>
          <span id="ws-status" class="status disconnected">Disconnected</span>
        </div>
        <div class="metric">
          <span>Messages:</span>
          <span id="ws-messages">0</span>
        </div>
        <div class="metric">
          <span>Avg Latency:</span>
          <span id="ws-latency">0ms</span>
        </div>
        <div class="metric">
          <span>Last Seq:</span>
          <span id="ws-seq">-</span>
        </div>
      </div>
    </div>
    
    <div class="server-stats">
      <h3>Server Statistics</h3>
      <div class="metric">
        <span>SSE Clients:</span>
        <span id="server-sse-clients">0</span>
      </div>
      <div class="metric">
        <span>WS Clients:</span>
        <span id="server-ws-clients">0</span>
      </div>
      <div class="metric">
        <span>Total Messages:</span>
        <span id="server-messages">0</span>
      </div>
      <div class="metric">
        <span>Uptime:</span>
        <span id="server-uptime">0s</span>
      </div>
    </div>
    
    <div class="comparison">
      <h3>Performance Analysis</h3>
      <div id="performance-summary">Connecting...</div>
    </div>
  </div>

  <script>
    // Client state
    let sseMetrics = { messages: 0, latencies: [], connected: false };
    let wsMetrics = { messages: 0, latencies: [], connected: false };
    
    // Configuration
    const MAX_LATENCY_SAMPLES = 100; // Prevent memory leak by limiting array size
    let wsReconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY = 2000;
    
    // Helper function to manage latency arrays size
    function addLatency(metricsObj, latency) {
      metricsObj.latencies.push(latency);
      if (metricsObj.latencies.length > MAX_LATENCY_SAMPLES) {
        metricsObj.latencies.shift(); // Remove oldest sample
      }
    }
    
    // Helper function for safe JSON parsing
    function safeJsonParse(jsonString) {
      try {
        return JSON.parse(jsonString);
      } catch (error) {
        console.error('JSON parsing error:', error);
        return null;
      }
    }
    
    // SSE Connection
    const eventSource = new EventSource('/sse');
    
    eventSource.onopen = () => {
      sseMetrics.connected = true;
      document.getElementById('sse-status').textContent = 'Connected';
      document.getElementById('sse-status').className = 'status connected';
    };
    
    eventSource.onmessage = event => {
      const data = safeJsonParse(event.data);
      if (!data) return; // Skip if JSON parsing failed
      
      const latency = Date.now() - data.ts;
      
      sseMetrics.messages++;
      addLatency(sseMetrics, latency);
      
      document.getElementById('sse-messages').textContent = sseMetrics.messages;
      document.getElementById('sse-seq').textContent = data.seq;
      
      if (sseMetrics.latencies.length > 0) {
        const avgLatency = sseMetrics.latencies.reduce((a, b) => a + b, 0) / sseMetrics.latencies.length;
        document.getElementById('sse-latency').textContent = Math.round(avgLatency) + 'ms';
      }
      
      updateComparison();
    };
    
    eventSource.onerror = () => {
      sseMetrics.connected = false;
      document.getElementById('sse-status').textContent = 'Error';
      document.getElementById('sse-status').className = 'status disconnected';
    };
    
    // WebSocket Connection with reconnection logic
    let ws;
    
    function connectWebSocket() {
      ws = new WebSocket(`ws://${window.location.host}/ws`);
      
      ws.onopen = () => {
        wsMetrics.connected = true;
        wsReconnectAttempts = 0; // Reset reconnect attempts on successful connection
        document.getElementById('ws-status').textContent = 'Connected';
        document.getElementById('ws-status').className = 'status connected';
        console.log('WebSocket connected');
      };
      
      ws.onmessage = event => {
        const data = safeJsonParse(event.data);
        if (!data) return; // Skip if JSON parsing failed
        
        const latency = Date.now() - data.ts;
        
        wsMetrics.messages++;
        addLatency(wsMetrics, latency);
        
        document.getElementById('ws-messages').textContent = wsMetrics.messages;
        document.getElementById('ws-seq').textContent = data.seq;
        
        if (wsMetrics.latencies.length > 0) {
          const avgLatency = wsMetrics.latencies.reduce((a, b) => a + b, 0) / wsMetrics.latencies.length;
          document.getElementById('ws-latency').textContent = Math.round(avgLatency) + 'ms';
        }
        
        updateComparison();
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        wsMetrics.connected = false;
        document.getElementById('ws-status').textContent = 'Error';
        document.getElementById('ws-status').className = 'status disconnected';
      };
      
      ws.onclose = (event) => {
        wsMetrics.connected = false;
        document.getElementById('ws-status').className = 'status disconnected';
        console.log('WebSocket disconnected:', event.code, event.reason);
        
        // Attempt to reconnect if not intentionally closed
        if (event.code !== 1000 && wsReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          wsReconnectAttempts++;
          document.getElementById('ws-status').textContent = `Reconnecting... (${wsReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`;
          setTimeout(() => {
            console.log(`WebSocket reconnect attempt ${wsReconnectAttempts}`);
            connectWebSocket();
          }, RECONNECT_DELAY);
        } else if (wsReconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
          document.getElementById('ws-status').textContent = 'Failed to reconnect';
        } else {
          document.getElementById('ws-status').textContent = 'Disconnected';
        }
      };
    }
    
    // Initialize WebSocket connection
    connectWebSocket();
    
    // Update server stats every 2 seconds with error handling
    const statsInterval = setInterval(() => {
      fetch('/api/stats')
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(stats => {
          document.getElementById('server-sse-clients').textContent = stats.sseClients;
          document.getElementById('server-ws-clients').textContent = stats.wsClients;
          document.getElementById('server-messages').textContent = stats.messagesSent;
          document.getElementById('server-uptime').textContent = Math.round(stats.uptime / 1000) + 's';
        })
        .catch(error => {
          console.error('Failed to fetch server stats:', error);
        });
    }, 2000);
    
    // Performance comparison
    function updateComparison() {
      if (sseMetrics.latencies.length > 0 && wsMetrics.latencies.length > 0) {
        const sseAvg = sseMetrics.latencies.reduce((a, b) => a + b, 0) / sseMetrics.latencies.length;
        const wsAvg = wsMetrics.latencies.reduce((a, b) => a + b, 0) / wsMetrics.latencies.length;
        
        const faster = sseAvg < wsAvg ? 'SSE' : 'WebSocket';
        const difference = Math.abs(sseAvg - wsAvg);
        
        document.getElementById('performance-summary').innerHTML = 
          `${faster} is faster by ${Math.round(difference)}ms average latency`;
      }
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      // Close WebSocket connection gracefully
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close(1000, 'Page unloading');
      }
      
      // Close SSE connection
      if (eventSource) {
        eventSource.close();
      }
      
      // Clear intervals
      clearInterval(statsInterval);
    });
    
    // Handle page visibility changes (e.g., tab switching)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.log('Page hidden, connections may be throttled');
      } else {
        console.log('Page visible again');
      }
    });
  </script>
</body>
</html>
